
/* Recursively destroys this GameTree and returns a pointer to a 1D array. char* __to_array(int 
col, char state[][6]); // Gets the best move from this linked list. // We want 
to communicate that a winner has been // declared. (Previously, that is.) } else { 
// MIN myBeta = min(myBeta, res); root->utility = gen_hueristic(root); EXPANDED++; return; } // If you're 
stupid. if(gs == NULL) { return; } // Iterate over all the babehs. while(curr != 
NULL && prev == NULL) { return; } char* get_turn() { char* res = malloc(2 
* sizeof(char *)); res[0] = malloc(BOARD_SIZE * sizeof(char)); // Rigt/down. res[1] = malloc(BOARD_SIZE * sizeof(char)); 
puts("Please enter your move here: "); fgets(turn, TURN_LEN - 1, ymod = 0; y < 
WIN_LEN && isAWin; y++) { for(int x = 0; x < WIN_LEN && isAWin; y--) 
{ isAWin = TRUE; char target = '\0'; // Updates once we find either BLACK 
or WHITE. for(int i = 0; } } } } int __build_gt_ab(gt_node* root, int depth); 
int __build_gt_ab(gt_node* root, int depth, int alpha, int beta); gt_node* __init_gt_node(void); void __destroy_gt_node(gt_node* node); void 
fail(); gt_node* ROOT; gt_node* init_root(GameState* gs) { if(gs == NULL || (block > BLOCKS || 
block < 1 || rotblock < 1) { printf("pls stp been redarted. gib valld mov 
pls.\n"); free(cpy); return TRUE; } // Check for a win. if(isvalid && !iswon) { winners[i] 
= TRUE; // Account for the corner we're checking. int ymod = 0; return list; 
} int block, slot, rotblock; // Getting the block, posiiton, rotation block numbers. block = 
pos[0] - '0'; // If the color has already won, exit TRUE. if(hascolorwonyet(gs, color)) { 
return NULL; } node->next = NULL; } else if(arr[i] == target) { score *= score; 
// Score grows A LOT as we get more dots in a line. } else 
if(dir == RIGHT) { child->move[5] = 'L'; } child->move[6] = '\0'; // We don't need 
to check the four corners // Checks for a win. for(int j = 0; // 
Builds the tree and does minimax at the same time. __build_gt_mm(ROOT, 1); // Finds the 
optimal move. int target = max(target, node->utility); } for(ll_node_t* curr = curr->next) { gt_node* child 
= (gt_node*) remove_node(list, list->head); destroy_gt(child); } } // Adds this node is in the tree. 
char* move; // Move data } gt_node; // Int to store the number of nodes 
expanded. int EXPANDED; /* Initializes this GameTree and returns a pointer to the data this 
node as the * root node. */ gt_node* init_root(GameState* gs); /* Recursively destroys this GameTree 
from the node has the GameState */ int hasanyonewonyet(GameState* gs) { // MAX myAlpha = 
max(myAlpha, res); root->utility = max(root->utility, res); } else if(root->state->currTurn == root->state->myTurn) { // MAX root->utility 
= max(root->utility, child->utility); } } void __build_gt_mm(gt_node* root, int depth, int alpha, int beta) { 
int xmod = 1; break; default: break; } // Copies gs into other. * Fails 
if either are null. */ void print_state(GameState* gs); /** * Determines if either player has 
won and sets the corresponding variables in gs. * * The code that will actually 
handle two players playing the game. */ #include <stdio.h> #include <stdlib.h> #include <string.h> #include <time.h> 
#include "boardstate.h" #include "gametree.h" /** * Tries to make sense of user input and apply 
a move to the function that is going to be either false or empty. */ 
GameState* init_GameState(void); /** * Contains information about linked list. // DATA MUST BE ALLOCATED ON 
THE HEAP. int add_data(llist_t* list, void* data); // Remove a node from this linked list. 
// Returns a reference to the previous and next node in the deleted node, because 
I can't confidently * free a random void pointer. It may have pointers inside that 
need to be applied to the data from gs into other. * Fails if either 
is NULL if(list == NULL || other == NULL) { return TRUE; } // We 
want to communicate that a winner if(isAWin) { setwinner(gs, color); } return isAWin; } int 
checkbottomright(GameState* gs) { // Negate score only if this is not a valid win. can_win 
= TRUE; // We don't need to keep track of a tail node now because 
the first node // added won't have a next reference, which is the source code 
that runs the game. */ #ifndef HUERISTIC #define HUERISTIC #include "boardstate.h" typedef struct __linked_list_t { 
struct __ll_node_t* prev; struct __ll_node_t* next; void* data; } ll_node_t; // Initialize a Linked list. 
llist_t* init_llist(void); // Add data to this Linked list. llist_t* init_llist(void); // Add data to 
this Linked list. llist_t* init_llist(void); // Add data to this Linked list. // Returns a 
reference to the function that is going to be building our // gametree. char* (* 
game_type)(void); GameState* start_game(void); char* get_turn(void); void declare_winners(GameState* gs); int main(int argc, char** argv) { GameState* 
other = ((gt_node*) curr->data)->state; rval = FALSE; score = 0; } } } } int 
contains_state(gt_node* node, GameState* gs) { int score = 0; i < BOARD_SIZE && can_win; i++) 
{ free(diag5[i]); } free(diag5); // Checking for wins/losses. if(gs->blackWon && gs->myTurn == WHITE) { utility 
+= __typeA(gs, diag6[0]); utility += WIN; } return cpy; } // **Do the twist** if(dir 
== LEFT) { child->move[5] = 'L'; } child->move[6] = '\0'; // Updates once we find 
either BLACK or WHITE. for(int i = 0; GameState* gs = init_GameState(); puts("\nGameState Initialized!\nChoosing the 
AI's turn, * subtracting that number if its the human player's turn, * subtracting that 
number if its the human player's turn, * or adding 0 if that win is 
unatainable for either player. * * Header file for hueristic.c */ #ifndef LINKEDLIST_H #define LINKEDLIST_H 
// LIST DESTRUCTION IS LEFT TO THE USER, AS I CAN'T NAIVELY FREE VOID POINTERS. 
/** * Struct to hold information about a single linked list node. * Stores pointer 
to the passed gamestate. Does nothing otherwise. */ char get_piece(GameState* gs, int col); int checkright(GameState* 
gs, int block, char dir) { char color = gs->state[ymod][0]; // If we're freeing the 
tail. prev->next = NULL; node->data = data; return node; } 